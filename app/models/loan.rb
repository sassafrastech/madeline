# == Schema Information
#
# Table name: loans
#
#  amount                      :decimal(, )
#  created_at                  :datetime         not null
#  currency_id                 :integer
#  division_id                 :integer
#  first_interest_payment_date :date
#  first_payment_date          :date
#  id                          :integer          not null, primary key
#  length_months               :integer
#  loan_type_value             :string
#  name                        :string
#  organization_id             :integer
#  organization_snapshot_id    :integer
#  primary_agent_id            :integer
#  project_type_value          :string
#  projected_return            :decimal(, )
#  public_level_value          :string
#  rate                        :decimal(, )
#  representative_id           :integer
#  secondary_agent_id          :integer
#  signing_date                :date
#  status_value                :string
#  target_end_date             :date
#  updated_at                  :datetime         not null
#
# Indexes
#
#  index_loans_on_currency_id               (currency_id)
#  index_loans_on_division_id               (division_id)
#  index_loans_on_organization_id           (organization_id)
#  index_loans_on_organization_snapshot_id  (organization_snapshot_id)
#
# Foreign Keys
#
#  fk_rails_5a4bc9458a  (division_id => divisions.id)
#  fk_rails_7a8d917bd9  (secondary_agent_id => people.id)
#  fk_rails_ade0930898  (currency_id => currencies.id)
#  fk_rails_dc1094f4ed  (organization_id => organizations.id)
#  fk_rails_ded298065b  (representative_id => people.id)
#  fk_rails_e90f6505d8  (primary_agent_id => people.id)
#

class Loan < ActiveRecord::Base
  include Translatable, MediaAttachable, OptionSettable

  belongs_to :division
  belongs_to :organization
  belongs_to :primary_agent, class_name: 'Person'
  belongs_to :secondary_agent, class_name: 'Person'
  belongs_to :currency
  belongs_to :representative, class_name: 'Person'
  belongs_to :organization_snapshot

  has_many :project_steps, as: :project
  has_many :project_logs, through: :project_steps


  # define accessor like convenience methods for the fields stored in the Translations table
  attr_translatable :summary, :details

  # beware, the methods generated by this include will fail without the corresponding OptionSet records existing in the database
  attr_option_settable :status, :loan_type, :project_type, :public_level


  validates :division_id, presence: true

  scope :with_division, -> { includes(:division) }
  scope :with_organization, -> { includes(:organization) }
  scope :status, ->(status) {
    case status
    when 'all'
      all
    else
      where(status_option_id: STATUS_OPTIONS.value_for(status))
    end
  }
  scope :visible, -> { where.not(publicity_status: 'hidden') }

  # todo: proper handling needs to be defined, probably a pre-populated and editable display name
  def name
    "Project with #{organization.try(:name)}"
  end

  # todo: shall we migrate the display usage to the more verbose version?
  def status
    status_label
  end

  def loan_type
    loan_type_label
  end

  # the special name of a default step to use/create when migrating a log without a step
  DEFAULT_STEP_NAME = '[default]'

  # creates / reuses a default step when migrating ProjectLogs without a proper owning step
  # beware, not at all optimized, but sufficient for migration.
  # not sure if this will be useful beyond migration.  if so, perhaps worth better optimizing,
  # if not, can remove once we're past the production migration process
  def default_step
    step = project_steps.select{ |s| s.summary == DEFAULT_STEP_NAME }.first
    unless step
      # Could perhaps optimize this with a 'find_or_create_by',
      # but would be tricky with the translatable 'summary' field,
      # and it's nice to be able to log the operation.
      logger.info { "default step not found for loan[#{id}] - creating" }
      step = project_steps.create
      step.update({summary: DEFAULT_STEP_NAME})
    end
    step
  end

  def amount_formatted
    amount.to_s
  end


  STATUS_ACTIVE_VALUE = 'active'
  STATUS_COMPLETED_VALUE = 'completed'

  def self.status_active_id
    status_option_set.id_for_value(STATUS_ACTIVE_VALUE)
  end



  ##
  ## todo: further review and cleanup of legacy code
  ##

  scope :country, ->(country) {
    joins(division: :super_division).where('super_divisions_Divisions.Country' => country) unless country == 'all'
  }

  def self.default_filter
    {
      status: 'active',
      country: 'all',
    }
  end

  def self.filter_by(params)
    params.reverse_merge! self.default_filter
    params[:country] = 'Argentina' if params[:division] == :argentina
    scoped = self.all
    scoped = scoped.country(params[:country]) if params[:country]
    scoped = scoped.status(params[:status]) if params[:status]
    scoped
  end

  def country
    # TODO: Temporary fix sets country to US when not found
    @country ||= organization.try(:country) || Country.find_by(iso_code: 'US')
  end

  def location
    if self.organization.try(:city).present?
      self.organization.city + ', ' + self.country.name
    else
      self.country.name
    end
  end

  def signing_date_long
    I18n.l self.signing_date, format: :long if self.signing_date
  end

  def coop_media(limit=100, images_only=false)
    get_media('Cooperatives', self.cooperative.try(:id), limit, images_only)
  end

  def loan_media(limit=100, images_only=false)
    get_media('Loans', self.id, limit, images_only)
  end

  def log_media(limit: 100, images_only: false)
    media = []
    self.logs('date').each do |log|
      media += log.get_media(limit: limit - media.count, images_only: images_only)
      return media unless limit > media.count
    end
    media
  end

  def featured_pictures(limit=1)
    pics = []
    coop_pics = organization.get_media(limit: limit, images_only: true).to_a
    # use first coop picture first
    pics << coop_pics.shift if coop_pics.count > 0
    return pics unless limit > pics.count
    # then loan pics
    pics += get_media(limit: limit - pics.count, images_only: true).to_a
    return pics unless limit > pics.count
    # then log pics
    pics += self.log_media(limit: limit - pics.count, images_only: true)
    return pics unless limit > pics.count
    # then remaining coop pics
    pics += coop_pics[0, limit - pics.count]
    pics
  end

  def thumb_path
    if !self.featured_pictures.empty?
      self.featured_pictures.first.item.thumb
    else
      '/assets/ww-avatar-watermark.png'
    end
  end

  # def amount_formatted
  #   currency_format(self.amount, self.currency)
  # end

  def project_events(order_by="completed_date IS NULL, completed_date, scheduled_date")
    @project_events ||= project_steps.includes(:project_logs).order(order_by)
    @project_events.reject do |p|
      # Hide past uncompleted project events without logs (for now)
      !p.completed? && p.project_logs.empty? && p.scheduled_date <= Time.zone.now
    end
  end

  def logs(order_by='date DESC')
    @logs ||= project_logs.order(order_by)
  end
end
