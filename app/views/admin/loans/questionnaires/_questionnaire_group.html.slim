  / Note: the grouping of optional questions that happens here and in LoanQuestionnairesView
  / should probably be refactored someday to happen in the model
  div
    - optional_encountered = false
    - optionals_exist = roots.any? { |i| !i.required_for?(@loan) }
    - requireds_exist = roots.any? { |i| i.required_for?(@loan) }

    - roots.each_with_index do |question, idx|
      / Add page break for top-level groups with answered questions
      / Also add page break for business model canvas answered question
      - response = response_set.response(question)
      - if (question.data_type == "business_canvas" || (question.data_type == 'group' && question.parent.root?)) \
          && !response.blank?
        / Close and reopen fieldset with new group/page
        - if optional_encountered && @print_view
          </fieldset>
          - reopen_fieldset = true

        / Page header for print view
        = render "admin/loans/questionnaires/page_header"

      - optional = !question.required_for?(@loan)
      - start_of_optional_group = !optional_encountered && optionals_exist && requireds_exist && optional
      - if @print_view && (reopen_fieldset || (start_of_optional_group && !response.blank?))
        - optional_encountered = true; reopen_fieldset = false
        <fieldset class="optional_questions"><legend>#{t 'questionnaires.optional_questions'}</legend>

      - css_class = optional ? 'optional' : 'required'

      / Don't print unanswered questions or groups
      - css_class += ' hidden-print' if response.blank? || response.not_applicable?
      - css_class += " #{question.status}"

      .question data-level=question.depth data-type=question.data_type data-id=question.id class=css_class
        - index_str = (indices + [idx + 1]).join(".")

        span.tree-view
          - if !question.leaf?
            = render "admin/loans/questionnaires/progress_bar", object: response

          - if question.data_type == 'group'
            - header_tag = {tag: %i(h3 h4 h5)[question.depth] || :h5}
            *header_tag
              = question.full_number_and_label
          - else
            .question-label = question.full_number_and_label

        - if question.explanation.present?
          .help-block.hidden-print.tree-view = simple_format(question.explanation.to_s)

        / Recurse if group, else render
        - if question.data_type == 'group'
          - if (filtered_children = question.children_applicable_to(@loan)).present?
            = render("admin/loans/questionnaires/questionnaire_group",
              f: f, response_set: response_set, roots: filtered_children,
              parents: parents + [question], indices: indices + [idx + 1])

        - else
          .answer-wrapper.tree-view
            - if response.has_rating?
              - if response.rating.present?
                .view-element.answer = "#{I18n.t('loan.rating')}: #{response.rating}"
              = f.input_field :"#{question.attribute_sym}[rating]", as: :select, selected: response.rating,
                collection: Array(1..5), prompt: I18n.t("select_prompt"), data: {rating: true}

            - if response.has_number?
              - if response.number.present?
                .view-element.answer = response.number
              = f.input_field :"#{question.attribute_sym}[number]", as: :decimal, value: response.number

            - if response.has_text?
              - if response.text.present?
                .view-element.answer = simple_format(response.text)
              = f.input_field :"#{question.attribute_sym}[text]", as: response.text_form_field_type,
                value: response.text

            - if response.has_string?
              - if response.string.present?
                .view-element.answer = simple_format(response.string)
              = f.input_field :"#{question.attribute_sym}[string]", value: response.string

            - if response.has_boolean?
              - if response.boolean.present?
                .view-element.answer = t(response.boolean == "yes" ? "reply_yes" : "reply_no")
              = f.input_field :"#{question.attribute_sym}[boolean]", as: :select, selected: response.boolean,
                collection: %i(yes no), label_method: ->(i) { t("reply_#{i}") },
                prompt: I18n.t("select_prompt"), data: {boolean: true}

            - if response.has_breakeven_table?
              - if response.breakeven_report.present?
                .view-element
                  = render "admin/loans/questionnaires/breakeven_table_report", report: response.breakeven_report
                  = render "admin/loans/questionnaires/breakeven_charts", report: response.breakeven_report, id: response.loan_question.id
                  - if response.breakeven_report[:periods] > 1
                    = render "admin/loans/questionnaires/breakeven_rampup/main", report: response.breakeven_report
                .form-element
                  = render 'admin/loans/questionnaires/breakeven_table_question', f: f,
                    question: question, data: response.breakeven_hash, total_fixed_costs: response.breakeven_report[:total_fixed_costs]
              - else
                .form-element
                  = render 'admin/loans/questionnaires/breakeven_table_question', f: f,
                    question: question, data: response.breakeven_hash, total_fixed_costs: 0

            - if response.has_business_canvas?
              .answer class=('form-element' if response.business_canvas_blank?)
                = render 'admin/loans/questionnaires/business_model_canvas', f: f,
                  question: question, data: response.business_canvas

            - if response.has_linked_document?
              = render 'admin/loans/questionnaires/linked_document', f: f,
                question: question, document: response.linked_document

            .not-applicable
              / Not Applicable
                / Debugging
                /= response.inspect
                / = question.attribute_sym

              - if response.not_applicable
                .view-element.answer Not applicable

              .form-element
                / = f.input :"#{question.attribute_sym}[not_applicable]"
                input type="checkbox" name="loan_response_set[#{question.attribute_sym}[not_applicable]]"
                label for="loan_response_set[#{question.attribute_sym}[not_applicable]]" Not applicable

            - if !response.group? && response.blank?
              .view-element.answer.blank = t("loan.no_answer")

    - if optional_encountered && @print_view
      </fieldset>
